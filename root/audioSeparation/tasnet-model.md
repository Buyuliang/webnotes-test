# tasnet-model

## ✅ 一、我们设计一个最简单系统

设定：
```bash
L = 2          # 每帧长度
stride = 1     # 重叠 50%
N = 2          # 两个基
```
## ✅ 二、原始波形


设真实波形：
$$x = [1,\ 2,\ 3]$$
长度 T=3
## ✅ 三、Encoder（我们人工设计）
我们设计两个“基函数”：
```bash
basis1 = [1, 0]
basis2 = [0, 1]
```
什么意思？

第一个基只看第一个采样
第二个基只看第二个采样
这其实就是：

不做变换，只是把帧拆开

✅ 切帧
stride=1，所以：

帧1： [1, 2]

帧2：     [2, 3]
✅ 计算特征（卷积）
因为basis1=[1,0]，basis2=[0,1]

帧1:

```bash
特征1 = 1
特征2 = 2
```
帧2:
```bash
特征1 = 2
特征2 = 3
```
所以：
$$mixture_w =
\begin{bmatrix}
[1,2], \\
[2,3]
\end{bmatrix}$$
shape:
```bash
[N=2, K=2]
```

## ✅ 四、假设不分离（mask=1）

设：
```bash
est_mask = 全1
```
所以：
$$source_w = mixture_w$$

## ✅ 五、Decoder（必须设计成逆变换）
我们让 Decoder 的 Linear 做：

```bash
[特征1, 特征2] → [特征1, 特征2]
```

也就是说：
权重矩阵：
$$W =
\begin{bmatrix}
1 & 0 \\
0 & 1
\end{bmatrix}$$

✅ 帧1 重建
输入：
```bash
[1,2]
```
输出：
```bash
[1,2]
```

✅ 帧2 重建
输入：
```bash
[2,3]
```



输出：
```bash
[2,3]
```



现在我们得到：
```bash
帧1: [1,2]
帧2: [2,3]
```
## ✅ 六、Overlap and Add

stride=1

时间位置：
```bash
帧1: 0 1
帧2:   1 2
```
✅ 第一步
```bash
[1,2,0]
```
✅ 加帧2
```bash
[1,
 2+2,
 3]

= [1,4,3]
```
❗ 等等，不对！

原始是：
```bash
[1,2,3]
```
现在是：

```bash
[1,4,3]
```

为什么中间变4了？
因为重叠部分被加了两次！

## ✅ 七、关键：必须做缩放（完美重构条件）


在真实Conv‑TasNet里：
Encoder 和 Decoder 会自动学到：

重叠区域要除以重叠次数

我们人工修正：
让 Decoder 输出：
css复制代码复制代码帧1 = [1, 2]
帧2 = [2, 3]

但在重叠时：
重叠点除以2。

✅ 修正 overlap-add
重叠点 index=1 被加两次：
$$4 ÷ 2 = 2$$
得到：
$$[1,2,3]$$
✅ 完全恢复原始波形！

## ✅ 八、真正闭环总结


完整流程：
```bash
原始波形:        [1,2,3]

切帧:
[1,2]
[2,3]

Encoder:
→ 特征:
[1,2]
[2,3]

mask=1:
不变

Decoder:
→ 重建帧:
[1,2]
[2,3]

Overlap-add:
[1,4,3]

除以重叠次数:
[1,2,3]
```



✅ 完全闭环

## ✅ 九、为什么真实Conv‑TasNet不用手动除2？


因为：
Encoder 和 Decoder 是“可学习的”。
训练时会自动学到：

编码时缩小
解码时放大
或者基函数自动满足完美重构

就像：
STFT 用特殊窗函数保证：
$$窗1^2 + 窗2^2 = 1$$
